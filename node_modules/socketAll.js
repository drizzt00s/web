var utility = require('utlity.js');  
var fs = require("fs");  
module.exports.startSocket = function(){
    var express = require('express');
    var app = express();
    var server = require('http').createServer(app);
    var io = require('socket.io').listen(server);
    server.listen(8080);

    var storeSocket=[];
    var myClosure=null;
    var loopIndex=0;
    var storeNew=[];
    /*
    这个数组里面存的是所有当前的socket连接,即所有连上服务器的用户socket连接
    格式为[{f:userLogin,c:socket},{f:userLogin,c:socket}.........]
    数组每一个元素都是一个json,json有二个属性,f表示该socket连接的用户名,c表示该socket连接的实例
    */
    var stroeOnlineUSer=[];
    io.sockets.on("connection",function(socket){
        //客户端和服务器的socket连接完成
        // var result1=socket;
        // var result2=io.sockets;
        //result1是当前登录用户的那个socket连接实例json,存储的是该用户的信息
        //result2也是一个json,但是这个json储存的是当前服务器维护的所有sockets实例信息
        socket.on("watchOtherLogin2",function(d,fn){
            //added on 2013/10/24
            var username=d["username"];
            var falseName=d["falseName"];
            socket.set("username",username);
            var allSockets=io.sockets.sockets;//json
            var client = utility.prepareDb();
            var queryString="select whoExpectYouLogin from d where falseName='"+falseName+"'";
            client.query(queryString,function(e,r){
                if(e){
                    throw e;
                }
                if(r.length!=0){
                    var r=r[0]["whoExpectYouLogin"]; //包含用户名
                    if(r.length>0){
                        r=eval("("+r+")");
                        for(var j=0;j<r.length;j++){
                            for(var jj2 in allSockets){
                                var eachS=allSockets[jj2];
                                var thisUsername=eachS.store.data.username;
                                if(thisUsername==r[j]){
                                    eachS.emit("watchOtherLogin",{"user":falseName});
                                    break;  
                                }
                            }
                        }
                        fn();
                    }
                }
                return false;
                fn();
            });
        });

        socket.on("noticeLogin",function(d){
            var username=d["username"];
            var falseName=d["falseName"];
            socket.set("username",username);
            app.get("/WebstormProjects/web/views/onlineMember.ejs",function(req,res){
                // var r=io.sockets.clients();//array;
                var r=io.sockets.sockets;//json
                var storeAllOnlineUser=[];
                for(var i in r){
                    var eachSocket=r[i];
                    var username=eachSocket["store"]["data"]["username"];
                    storeAllOnlineUser.push(username);
                }
                storeAllOnlineUser=removeRedundant(storeAllOnlineUser);
                res.render("./onlineMember.ejs",{title:"在线用户",onlines:JSON.stringify(storeAllOnlineUser)});
            })
            //当用户登录进来的时，将这名用户的socket对象分别设置二个值，用户名和昵称
        });

        setTimeout(checkSockets,2000);
        function checkSockets(){
            var r=io.sockets.sockets;//json
            var storeOnlineUser=[];
            for(var i in r){
                var eachSocket=r[i]["store"]["data"]["account"];
                // 用户的昵称
                storeOnlineUser.push(eachSocket);
            }
            //for
            socket.emit("listenOthersSignOut",storeOnlineUser);
            setTimeout(checkSockets,2000);
        }
        //搜集当前所有在线用户,放在一个数组中去,然后通过socket发送到前端,这个函数的作用是每隔10秒告诉前端当前在线用户是哪些人


        function checkIsUserOnline(userfalse){
            var isUserOnline=false;
            var r=io.sockets.sockets;//json
            var storeOnlineUser=[];
            for(var i in r){
                var eachUserFalseName=r[i]["store"]["data"]["account"];
                //每个用户的昵称
                storeOnlineUser.push(eachUserFalseName);
            }
            for(var i=0;i<storeOnlineUser.length;i++){
                if(storeOnlineUser[i]==userfalse){
                    isUserOnline=true;
                    break;
                }
            }
            return isUserOnline;
        }
        //这个函数的逻辑和上一个函数checkSockets差不多,但是作用不一样,这个函数的作用是检查目标用户是不是在线


        function repeatBroadcast(o){
        /*
        var targetSocket=o.socket;
        var targetIcon=o.icon;
        var targetContents=o.contents;
        var targetFalseName=o.falseName;
        targetSocket.emit("receiveGlobalBroadcast",{"contents":targetContents,"iconUrl":targetIcon,"falseName":targetFalseName});
        socket.broadcast.emit("receiveGlobalBroadcast",{"contents":targetContents,"iconUrl":targetIcon,"falseName":targetFalseName});
        */
        }

        socket.on("globalBroadcast",function(d){
            var contents=d["d"];
            var username=d["username"];
            var falseName=d["falseName"];
            fs.exists( "./web/uploads/pic/"+username,function(ifExist){
                if(ifExist){
                    //用户有图片
                    fs.readdir("./web/uploads/pic/"+username,function(e,d){
                    if(e){
                        throw e; 
                    }
                    var userIcon= "../uploads/pic/"+username+"/"+d[0];
                    socket.emit("receiveGlobalBroadcast",{"contents":contents,"iconUrl":userIcon,"falseName":falseName});
                    socket.broadcast.emit("receiveGlobalBroadcast",{"contents":contents,"iconUrl":userIcon,"falseName":falseName});
                    function repeatBroadcast(){
                        socket.emit("receiveGlobalBroadcast",{"contents":contents,"iconUrl":userIcon,"falseName":falseName});
                        socket.broadcast.emit("receiveGlobalBroadcast",{"contents":contents,"iconUrl":userIcon,"falseName":falseName});
                        setTimeout(repeatBroadcast,10000);
                    }
                    setTimeout(repeatBroadcast,10000);
                    });
                }
                else{
                    //用户无图片
                    var userIcon="../uploads/pic/default/unknown.png";
                    socket.emit("receiveGlobalBroadcast",{"contents":contents,"iconUrl":userIcon,"falseName":falseName});
                    socket.broadcast.emit("receiveGlobalBroadcast",{"contents":contents,"iconUrl":userIcon,"falseName":falseName});
                    function repeatBroadcast(){
                        socket.emit("receiveGlobalBroadcast",{"contents":contents,"iconUrl":userIcon,"falseName":falseName});
                        socket.broadcast.emit("receiveGlobalBroadcast",{"contents":contents,"iconUrl":userIcon,"falseName":falseName});
                        setTimeout(repeatBroadcast,10000);
                    }
                    setTimeout(repeatBroadcast,10000);
                }
            });
        });

        socket.on("getSocketImageFlag",function(data,fn){
            if(data){
                fn();
            }
            sendSocketImage=function (req,res,imageForWhom,imageFromWhom){
                var uploadedImageName=(req.files)["myFile"]["name"];
                var imagePath=__dirname+"/uploads/pic/"+uploadedImageName;
                fs.readFile(imagePath,function(err,data){
                    if(err){
                        throw err;
                    }
                    for(var i=0;i<storeSocket.length;i++){
                        var eachSocketInfoV=storeSocket[i];//json
                        var getEachUserV=eachSocketInfoV.f;//string
                        if(imageForWhom==getEachUserV){
                            var targetSocketV=eachSocketInfoV.c;
                            var stringData=data.toString('base64');
                            var storeImageData={};
                            //这个json要存储表示该图片的字符串和谁发的,发给谁这三个信息
                            storeImageData["image"]=stringData;
                            storeImageData["forWhom"]=imageForWhom;
                            storeImageData["fromWhom"]=imageFromWhom;
                            targetSocketV.emit("receiveImage",storeImageData);
                            break;
                        }
                    }  
                });
            };
            //sendSocketImage
            sendOffLineSocketImage=function(req,res,imageForWhom,imageFromWhom){
                var storeUnreadMsgJson={};
                var unReadMsgFrom=imageFromWhom; //who sent the msg
                var unReadMsgTo=imageForWhom;//msg to whom
                var uploadedImageName=(req.files)["myFile"]["name"];
                var imagePath=__dirname+"/uploads/pic/"+uploadedImageName;
                fs.readFile(imagePath,function(error,data){
                    if(error){
                        throw error;
                    }
                    var unReadMsg=data;
                    // 这边的data就是二进制
                    var unReadMsg2=unReadMsg.toString('base64');
                    var storeUnreadMsg=unReadMsgFrom+"***********"+unReadMsg2+"***********"+unReadMsgTo;
                    //string
                    storeUnreadMsgJson["whoSent"]=storeUnreadMsg;//json
                    var Client =require("mysql").Client;
                    var client =new Client();
                    client.user="root";
                    client.password="5611559w";
                    client.query("USE user");
                    //check the user's unreadmsg field in db first to check if there is any value in the column
                    var queryStringIsValueExist="SELECT * FROM d WHERE falseName="+"'"+unReadMsgTo+"'";
                    client.query(queryStringIsValueExist,function(error,result){
                        if(error){
                            throw error;
                        }
                        var checkUnreadMsg=result;
                        if(!checkUnreadMsg[0]){
                            return false;
                        }
                        var r1=checkUnreadMsg[0].unreadimg;
                        //取得第一次查询时unreadmsg字段的值
                        if(!r1){
                            //db中没有这个用户的临时消息
                            var storeUnreadMsgInDb=[];//array
                            storeUnreadMsgInDb.push(JSON.stringify(storeUnreadMsgJson));;
                            //创建一个空数组，并且把本次的临时消息存到这个数组中,本次的消息是个json
                            var queryUpdateUnreadMsg="UPDATE d SET unreadimg="+"'"+storeUnreadMsgInDb+"'"+" WHERE falseName="+"'"+unReadMsgTo+"'"
                            //将数组storeUnreadMsgInDb存入字段unreadmsg
                            client.query(queryUpdateUnreadMsg,function(error){
                                if(error){
                                    throw error;
                                }
                                //临时信息在db中存储完毕

                            }); 
                        } else {
                            //该用户有临时信息没读，这些临时信息存储在数据库里的字段unreadmsg中
                            var currentUnMsg=checkUnreadMsg[0]["unreadimg"];//string

                            var currentUnreadMsgC=currentUnMsg.split(",");//array

                            currentUnreadMsgC.push(JSON.stringify(storeUnreadMsgJson));
                            var queryUpdateUnreadMsg2="UPDATE d SET unreadimg="+"'"+currentUnreadMsgC+"'"+" WHERE falseName="+"'"+unReadMsgTo+"'";
                            client.query(queryUpdateUnreadMsg2,function(error){
                                if(error){
                                    throw error;
                                }
                                //临时信息在db中存储完毕
                            });
                            //字段unreadmsg更新完毕,这个时候这个用户的临时消息一定超过一条
                        }
                        //else
                    });
                    //query for queryStringIsValueExist
                });
            }
            //sendOffLineSocketImage
        });
        //getSocketImageFlag:服务器收到一个用户发来的图片,并将这张图片转发给其他用户

        socket.on("returnImageToSelf",function(data){
            var whoSent=data.whoSent;
            //发图片的人
            var imageName=data.imageName;
            //图片名
            var imageUrl=__dirname+"/uploads/pic/"+imageName;
            //图片现在在服务器上的位置
            var imageSentTo=data.imageSentTo;
            //这张图片发给谁
            function getImage(){
                fs.readFile(imageUrl,function(error,data){
                    if(data){
                        var dataString=data.toString("base64");
                        //得出这张图片二进制代码的base64字符串表示
                        socket.emit("returnImageToWhoSent",{"image":dataString,"toWhom":imageSentTo});
                        //在调用下面这个函数之前,必须先确定目标用户是否在线
                        //下面这个函数的作用是将用户A发送到服务器的图片转发给用户B,要先确定用户B是否在线
                    }
                    else{ 
                        getImage();
                    }
                });
                //readFile
            }//getImage
            getImage();
        });
        //event returnImageToSelf

        socket.on("getUnreadImg",function(data){
            var whoSentRequestB=data.from;//用户昵称
            var whoSentMsgB=data.whoseMsg;//谁发给你的消息
            var Client =require("mysql").Client;
            var client =new Client();
            client.user="root";
            client.password="5611559w";
            client.query("USE user");
            var queryUnreadMsgInDbB="SELECT * FROM d WHERE falseName="+"'"+whoSentRequestB+"'";

            client.query(queryUnreadMsgInDbB,function(errorB1,resultB1){
                if(errorB1){
                    throw errorB1;
                }
                var checkUnreadMsgB1=resultB1;//arrays
                var r1B=checkUnreadMsgB1[0].unreadimg;//string
                if(!r1B){
                    return false;
                }
                var r2B=r1B.split(",");//array;This line may have a bug:can not call method split of none
                var fetchUnreadMsgB=[];
                //这个数组存储特定用户发送的所有未读信息
                var remainingUnreadMsgB=[];
                //这个数组存储不是这个特定用户发送的所有未读信息，这些信息会被再次更新到db中的unreadmsg字段
                for(var i=0;i<r2B.length;i++){
                    var eachJsonB=eval("("+r2B[i]+")");
                    var checkWhoSentB=eachJsonB["whoSent"];//string
                    //取得该用户所有在db中的未读信息！！！！
                    var eachWhoSentB=(checkWhoSentB.split("***********"))[0];
                    //每条未读信息是谁发送的
                    if(eachWhoSentB==whoSentMsgB){
                        fetchUnreadMsgB.push((checkWhoSentB.split("***********"))[1]);
                    } else {
                        remainingUnreadMsgB.push(r2B[i]);//array
                    }
                }//for
                var queryRemainingUnreadB="UPDATE d SET unreadimg="+"'"+remainingUnreadMsgB+"'"+"WHERE falseName="+"'"+whoSentRequestB+"'";
                client.query(queryRemainingUnreadB,function(errorB){
                    if(errorB){
                        throw errorB;
                    }
                    //return false;
                    socket.emit("returnUnreadImg",{msg:fetchUnreadMsgB,whoSent:whoSentMsgB});
                })
                //将其他用户的未读信息再次存到数据库中
            })
        });
        //getUnreadImg

        socket.on("getUnreadMsg",function(data){
            var whoSentRequest=data.from;
            var whoSentMsg=data.whoseMsg;
            var Client =require("mysql").Client;
            var client =new Client();
            client.user="root";
            client.password="5611559w";
            client.query("USE user");
            var queryUnreadMsgInDb="SELECT * FROM d WHERE account="+"'"+whoSentRequest+"'";
            client.query(queryUnreadMsgInDb,function(error,result){
                if(error){
                    throw error;
                }
                var checkUnreadMsg=result;//arrays
                if(!checkUnreadMsg){
                    return false;
                }
                var r1=checkUnreadMsg[0].unreadmsg;//string
                if(!r1){
                    return false;
                }
                var r2=r1.split(",");//array;This line may have a bug:can not call method split of none
                var fetchUnreadMsg=[];
                //这个数组存储特定用户发送的所有未读信息
                var fetchUnreadMsgTime=[];
                //这个数组存储特定用户发送的所有未读信息的发送时间
                var remainingUnreadMsg=[];
                //这个数组存储不是这个特定用户发送的所有未读信息，这些信息会被再次更新到db中的unreadmsg字段
                for(var i=0;i<r2.length;i++){
                    var eachJson=eval("("+r2[i]+")");
                    var checkWhoSent=eachJson["whoSent"];//string
                    //取得该用户所有在db中的未读信息！！！！
                    var eachWhoSent=(checkWhoSent.split("?"))[0];
                    //每条未读信息是谁发送的

                    if(eachWhoSent==whoSentMsg){
                        fetchUnreadMsg.push((checkWhoSent.split("?"))[1]);
                        fetchUnreadMsgTime.push((checkWhoSent.split("?"))[3]);
                    } else {
                        remainingUnreadMsg.push(r2[i]);//array
                    }
                }//for
                var queryRemainingUnread="UPDATE d SET unreadmsg="+"'"+remainingUnreadMsg+"'"+"WHERE account="+"'"+whoSentRequest+"'";
                client.query(queryRemainingUnread,function(error){
                    if(error){
                        throw error;
                    }
                    socket.emit("returnUnreadMsg",{msg:fetchUnreadMsg,whoSent:whoSentMsg,msgTime:fetchUnreadMsgTime});
                })
                //将其他用户的未读信息再次存到数据库中
            })
        });
        //getUnreadMsg

        socket.on("receiveImgNotReady",function(data){
            var storeUnreadMsgJson={};
            var unReadMsgFrom=data.from; //who sent the msg
            var unReadMsg=data.imgDetil; //what is the msg
            var unReadMsgTo=data.account;//msg to whom
            var storeUnreadMsg=unReadMsgFrom+"***********"+unReadMsg+"***********"+unReadMsgTo;
            storeUnreadMsgJson["whoSent"]=storeUnreadMsg;//json
            var Client =require("mysql").Client;
            var client =new Client();
            client.user="root";
            client.password="5611559w";
            client.query("USE user");
            //check the user's unreadmsg field in db first to check if there is any value in the column
            var queryStringIsValueExist="SELECT * FROM d WHERE falseName="+"'"+unReadMsgTo+"'";

            client.query(queryStringIsValueExist,function(error,result){
                if(error){
                    throw error;
                }
                var checkUnreadMsg=result;
                if(!checkUnreadMsg[0]){
                    return false;
                }
                var r1=checkUnreadMsg[0].unreadimg;
                //取得第一次查询时unreadmsg字段的值
                if(!r1){
                    //db中没有这个用户的临时消息
                    var storeUnreadMsgInDb=[];//array

                    storeUnreadMsgInDb.push(JSON.stringify(storeUnreadMsgJson));

                    //创建一个空数组，并且把本次的临时消息存到这个数组中,本次的消息是个json
                    var queryUpdateUnreadMsg="UPDATE d SET unreadimg="+"'"+storeUnreadMsgInDb+"'"+" WHERE falseName="+"'"+unReadMsgTo+"'";
                    //将数组storeUnreadMsgInDb存入字段unreadmsg
                    client.query(queryUpdateUnreadMsg,function(error){
                        if(error){
                            throw error;
                        }
                        //临时信息在db中存储完毕
                    });
                } else {
                    //该用户有临时信息没读，这些临时信息存储在数据库里的字段unreadmsg中
                    var currentUnMsg=checkUnreadMsg[0]["unreadimg"];//string

                    var currentUnreadMsgC=currentUnMsg.split(",");//array

                    currentUnreadMsgC.push(JSON.stringify(storeUnreadMsgJson));
                    var queryUpdateUnreadMsg2="UPDATE d SET unreadimg="+"'"+currentUnreadMsgC+"'"+" WHERE falseName="+"'"+unReadMsgTo+"'";
                    client.query(queryUpdateUnreadMsg2,function(error){
                        if(error){
                            throw error;
                        }
                        //临时信息在db中存储完毕
                    });
                    //字段unreadmsg更新完毕,这个时候这个用户的临时消息一定超过一条
                }
                //else
            });
            //query for queryStringIsValueExist
        });
        //接受客户端未读取的消息，存在db中，在适当的时候回传，不能存在cookie中，因为有大小限制

        socket.on("receiveMsgNotReady",function(data){
            var storeUnreadMsgJson={};
            var whenSent=data.whenSent;//信息是什么时候发的
            var unReadMsgFrom=data.from; //who sent the msg
            var unReadMsg=data.msgDetil; //what is the msg
            var unReadMsgTo=data.account;//msg to whom
            //var storeUnreadMsg=unReadMsgFrom+"?"+unReadMsg+"?"+unReadMsgTo;
            var storeUnreadMsg=unReadMsgFrom+"?"+unReadMsg+"?"+unReadMsgTo+"?"+whenSent;
            storeUnreadMsgJson["whoSent"]=storeUnreadMsg;//json
            var Client =require("mysql").Client;
            var client =new Client();
            client.user="root";
            client.password="5611559w";
            client.query("USE user");
            //check the user's unreadmsg field in db first to check if there is any value in the column
            var queryStringIsValueExist="SELECT * FROM d WHERE account="+"'"+unReadMsgTo+"'";
            client.query(queryStringIsValueExist,function(error,result){
                if(error){
                    throw error;
                }
                var checkUnreadMsg=result;
                if(!checkUnreadMsg[0]){
                    return false;
                }
                var r1=checkUnreadMsg[0].unreadmsg;
                //取得第一次查询时unreadmsg字段的值
                if(!r1){
                    //db中没有这个用户的临时消息
                    var  storeUnreadMsgInDb=[];//array
                    storeUnreadMsgInDb.push(JSON.stringify(storeUnreadMsgJson));
                    //创建一个空数组，并且把本次的临时消息存到这个数组中,本次的消息是个json
                    var queryUpdateUnreadMsg="UPDATE d SET unreadmsg="+"'"+storeUnreadMsgInDb+"'"+" WHERE account="+"'"+unReadMsgTo+"'";
                    //将数组storeUnreadMsgInDb存入字段unreadmsg
                    client.query(queryUpdateUnreadMsg,function(error){
                        if(error){
                            throw error;
                        }
                    });
                } else {
                    //该用户有临时信息没读，这些临时信息存储在数据库里的字段unreadmsg中
                    var currentUnMsg=checkUnreadMsg[0]["unreadmsg"];//string
                    var currentUnreadMsgC=currentUnMsg.split(",");//array
                    currentUnreadMsgC.push(JSON.stringify(storeUnreadMsgJson));
                    var queryUpdateUnreadMsg2="UPDATE d SET unreadmsg="+"'"+currentUnreadMsgC+"'"+" WHERE account="+"'"+unReadMsgTo+"'";
                    client.query(queryUpdateUnreadMsg2,function(error){
                        if(error){
                            throw error;
                        }
                    });
                }
            });
            //query for queryStringIsValueExist
        });
        //接受客户端未读取的消息，存在db中，在适当的时候回传，不能存在cookie中，因为有大小限制

        socket.on("sendFalseName",function(data){
            var userLogin=data;
            //用户的昵称
            socket.set("account",userLogin);
            //将用户的昵称存在socket实例中,注意!:即使以后用户刷新页面,这个值也不会变,但是socket.id的值会变!
            var storeEachInput={};
            storeEachInput.f=userLogin;
            storeEachInput.c=socket
            for(var i=0;i<storeSocket.length;i++){
                var eachSocketInfo=storeSocket[i];
                var checkSocketInArray=eachSocketInfo.f;//数组里的值
                if(checkSocketInArray==userLogin){
                    storeSocket.splice(i,1);
                    break;
                }
            }
            storeSocket.push(storeEachInput);
        });

        socket.on("privateChat",function(data){
            //获取前端传进来的数据
            var msgSentTime=data.whenSent;
            var msg=data.eachMsg.msg;
            var toWhom=data.eachMsg.toWhom;
            //信息发给谁
            var fromWhom=data.eachMsg.fromWhom;
            var isUserOnline=checkIsUserOnline(toWhom);
            //这里要判断用户在线还是不在线
            if(isUserOnline){
                for(var i=0;i<storeSocket.length;i++){
                    var eachSocketInfo=storeSocket[i];//json
                    var getEachUser=eachSocketInfo.f;//string
                    if(toWhom==getEachUser){
                        var targetSocket=eachSocketInfo.c;
                        targetSocket.emit("returnPrivateChatting",{from:fromWhom,msgContents:msg,whenSent:msgSentTime});
                        break;
                    }
                }
                //for 
            } else {
                //用户不在线
                var storeUnreadMsgJson={};
                var whenSent=data.whenSent;//信息是什么时候发的  
                var unReadMsgFrom=data.eachMsg.fromWhom; //who sent the msg
                var unReadMsg=data.eachMsg.msg; //what is the msg
                var unReadMsgTo=data.eachMsg.toWhom;//msg to whom
                var storeUnreadMsg=unReadMsgFrom+"?"+unReadMsg+"?"+unReadMsgTo+"?"+whenSent;
                storeUnreadMsgJson["whoSent"]=storeUnreadMsg;//json
                var Client =require("mysql").Client;
                var client =new Client();
                client.user="root";
                client.password="5611559w";
                client.query("USE user");
                //check the user's unreadmsg field in db first to check if there is any value in the column
                var queryStringIsValueExist="SELECT * FROM d WHERE falseName="+"'"+unReadMsgTo+"'";
                client.query(queryStringIsValueExist,function(error,result){
                    if(error){
                        throw error;
                    }
                    var checkUnreadMsg=result;
                    if(!checkUnreadMsg[0]){
                        return false;
                    }
                    var r1=checkUnreadMsg[0].unreadmsg;
                    //取得第一次查询时unreadmsg字段的值
                    if(!r1){
                        //db中没有这个用户的临时消息
                        var  storeUnreadMsgInDb=[];//array
                        storeUnreadMsgInDb.push(JSON.stringify(storeUnreadMsgJson));
                        //创建一个空数组，并且把本次的临时消息存到这个数组中,本次的消息是个json
                        var queryUpdateUnreadMsg="UPDATE d SET unreadmsg="+"'"+storeUnreadMsgInDb+"'"+" WHERE falseName="+"'"+unReadMsgTo+"'";
                        //将数组storeUnreadMsgInDb存入字段unreadmsg
                        client.query(queryUpdateUnreadMsg,function(error){
                            if(error){
                                throw error;
                            }
                        });
                    } else {
                        //该用户有临时信息没读，这些临时信息存储在数据库里的字段unreadmsg中
                        var currentUnMsg=checkUnreadMsg[0]["unreadmsg"];//string
                        var currentUnreadMsgC=currentUnMsg.split(",");//array
                        currentUnreadMsgC.push(JSON.stringify(storeUnreadMsgJson));
                        var queryUpdateUnreadMsg2="UPDATE d SET unreadmsg="+"'"+currentUnreadMsgC+"'"+" WHERE falseName="+"'"+unReadMsgTo+"'";
                        client.query(queryUpdateUnreadMsg2,function(error){
                            if(error){
                                throw error;
                            }
                            //临时信息在db中存储完毕
                        });
                        //字段unreadmsg更新完毕,这个时候这个用户的临时消息一定超过一条
                    }
                    //else
                });
                //query for queryStringIsValueExist
            }
        });
        //privateChat

        socket.on("updateNewMsgCounts",function(data){
            var msgTo=data.d;
            var queryString="select msgAsyn from d where falseName='"+msgTo+"'";
            setTimeout(delayQuery,1500);
            //将查询msgAsyn的逻辑设置一定时间的延迟 来保证下面的代码在运行时 msgAsyn字段已经做了更新
            function delayQuery(){
                var client = utility.prepareDb();
                client.query(queryString,function(error,d){
                    if(error){
                        throw error;
                    }
                    d=eval("("+d[0]["msgAsyn"]+")");  //解析msgAysn字段的格式
                    d=d["con"]; //数组,元素是json
                    var newMsgCounts=0; //isTheMsgNew
                    for(var i=0;i<d.length;i++){
                        if(d[i]["isTheMsgNew"]==1){
                            newMsgCounts++;
                        }
                    } 
                    queryString="select account from d where falseName='"+msgTo+"'";
                    client.query(queryString,function(error,d){
                        if(error){
                            throw error;
                        }
                        var thisUsername=d[0]["account"];
                        var s=io.sockets.sockets;
                        for(var c in s){
                            var eachS=s[c]; 
                            if(eachS.store.data.username==thisUsername){
                                eachS.emit("updateNewMsgTo",{"newMsg":newMsgCounts});
                                //client.end();
                                //break;
                            }
                        }
                    });
                });
            }
        });

        socket.on("disconnect",function(){
            console.log("socket disconnect");
        });

        //socket连接中断
        myClosure=checkIsUserOnline;
    })

};





